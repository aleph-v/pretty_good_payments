// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {PoseidonT3} from "poseidon-solidity/PoseidonT3.sol";
import {PoseidonT5} from "poseidon-solidity/PoseidonT5.sol";
import {IUpdateVerifier} from "../interfaces/IUpdateVerifier.sol";
import {Proof} from "./ZKVerifier.sol";

// Implements verification functions for an append only merkle tree addition verification

struct Leaf {
    address asset;
    uint256 amount;
    bytes32 blinding;
    bytes32 publicKey;
}

library Bytes32Poseidon {
    using PoseidonT5 for uint256[4];
    using PoseidonT3 for uint256[2];

    function hash(bytes32[2] memory data) internal pure returns (bytes32) {
        uint256[2] memory converted;
        assembly {
            converted := data
        }
        return (bytes32)(converted.hash());
    }

    function hash(bytes32[4] memory data) internal pure returns (bytes32) {
        uint256[4] memory converted;
        assembly {
            converted := data
        }
        return (bytes32)(converted.hash());
    }
}

library PredictableMerkleLib {
    uint256 constant TREE_DEPTH = 40;

    using Bytes32Poseidon for bytes32[2];
    using Bytes32Poseidon for bytes32[4];

    /// @notice Since the dirrect verification of a three element update is fairly cost intensive onchain we use a groth16 verifier
    /// @param publicInputs [anchorBefore, blockIndex, updates0, updates1, updates2, anchorAfter]
    /// @param proof groth16 proof of the predictableUpdate circom file.
    /// @param verifier The autogenerated verifier contract.
    function verfiyPredictableUpdate(IUpdateVerifier verifier, bytes32[6] memory publicInputs, Proof memory proof)
        public
        view
        returns (bool)
    {
        uint256[6] memory converted;
        assembly {
            converted := publicInputs
        }
        return verifier.verifyProof(proof._pA, proof._pB, proof._pC, converted);
    }

    /// @notice Computes the hash of a leaf in the tree using posiedon
    /// @param leaf The leaf
    /// @dev Note that we are doing a width 4 for the leaves and a width 2 in the tree, so do not use a domain seprator for leaves
    function hash(Leaf memory leaf) public pure returns (bytes32) {
        bytes32[4] memory data = [(bytes32)(bytes20(leaf.asset)), (bytes32)(leaf.amount), leaf.blinding, leaf.publicKey];
        // Hashes a leaf, should match the hash in the zk proof.
        return (bytes32)(data.hash());
    }
}
