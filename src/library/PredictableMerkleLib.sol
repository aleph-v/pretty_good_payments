// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {PoseidonT3} from "poseidon-solidity/PoseidonT3.sol";
import {PoseidonT5} from "poseidon-solidity/PoseidonT5.sol";
import {IUpdateVerifier} from "../interfaces/IUpdateVerifier.sol";
import {Proof} from "./ZKVerifier.sol";

// Implements verification functions for an append only merkle tree addition verification

struct Leaf {
    address asset;
    uint256 amount;
    bytes32 blinding;
    bytes32 publicKey;
}

library Bytes32Poseidon {
    using PoseidonT5 for uint256[4];
    using PoseidonT3 for uint256[2];

    function hash(bytes32[2] memory data) internal pure returns (bytes32) {
        uint256[2] memory converted;
        assembly {
            converted := data
        }
        return (bytes32)(converted.hash());
    }

    function hash(bytes32[4] memory data) internal pure returns (bytes32) {
        uint256[4] memory converted;
        assembly {
            converted := data
        }
        return (bytes32)(converted.hash());
    }
}

library PredictableMerkleLib {
    uint256 constant TREE_DEPTH = 40;

    using Bytes32Poseidon for bytes32[2];
    using Bytes32Poseidon for bytes32[4];

    /// @notice Since the dirrect verification of a three element update is fairly cost intensive onchain we use a groth16 verifier
    /// @param publicInputs [anchorBefore, blockIndex, updates0, updates1, updates2, anchorAfter]
    /// @param proof groth16 proof of the predictableUpdate circom file.
    /// @param verifier The autogenerated verifier contract.
    function verfiyPredictableUpdate(bytes32[6] memory publicInputs, Proof memory proof, IUpdateVerifier verifier)
        public
        view
        returns (bool)
    {
        uint256[6] memory converted;
        assembly {
            converted := publicInputs
        }
        return verifier.verifyProof(proof._pA, proof._pB, proof._pC, converted);
    }

    /// @notice Computes the hash of a leaf in the tree using posiedon
    /// @param leaf The leaf
    /// @dev Note that we are doing a width 4 for the leaves and a width 2 in the tree, so do not use a domain seprator for leaves
    function hashLeaf(Leaf memory leaf) public pure returns (bytes32) {
        bytes32[4] memory data = [(bytes32)(bytes20(leaf.asset)), (bytes32)(leaf.amount), leaf.blinding, leaf.publicKey];
        // Hashes a leaf, should match the hash in the zk proof.
        return (bytes32)(data.hash());
    }

    // TODO Not actually used
    function enforceInTree(Leaf memory leaf, bytes32 root, uint256 index, bytes32[] memory proof) public pure {
        assert(proof.length == TREE_DEPTH);
        assert(index < 2 ** TREE_DEPTH);

        bytes32 computed = hashLeaf(leaf);
        uint256 currentIndex = index;
        bytes32[2] memory held = [bytes32(0), bytes32(0)];
        for (uint256 i = 0; i < TREE_DEPTH; i++) {
            if (currentIndex % 2 == 0) {
                held[0] = computed;
                held[1] = proof[i];
            } else {
                held[0] = proof[i];
                held[1] = computed;
            }
            computed = held.hash();
            currentIndex = currentIndex / 2;
        }

        assert(computed == root);
    }
}
